\documentclass{article}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{listings}
\usepackage{cancel}
\usepackage{hyperref}
\usepackage{xcolor}
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    inputencoding=utf8,
    extendedchars=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
        *{0}{{{\color{numb}0}}}{1}
        {1}{{{\color{numb}1}}}{1}
        {2}{{{\color{numb}2}}}{1}
        {3}{{{\color{numb}3}}}{1}
        {4}{{{\color{numb}4}}}{1}
        {5}{{{\color{numb}5}}}{1}
        {6}{{{\color{numb}6}}}{1}
        {7}{{{\color{numb}7}}}{1}
        {8}{{{\color{numb}8}}}{1}
        {9}{{{\color{numb}9}}}{1}
        {:}{{{\color{punct}{:}}}}{1}
        {,}{{{\color{punct}{,}}}}{1}
        {\{}{{{\color{delim}{\{}}}}{1}
        {\}}{{{\color{delim}{\}}}}}{1}
        {[}{{{\color{delim}{[}}}}{1}
        {]}{{{\color{delim}{]}}}}{1}
        {é}{{\'e}}{1}%
        {è}{{\`e}}{1}%
        {à}{{\`a}}{1}%
        {ç}{{\c{c}}}{1}%
        {œ}{{\oe}}{1}%
        {ù}{{\`u}}{1}%
        {É}{{\'E}}{1}%
        {È}{{\`E}}{1}%
        {À}{{\`A}}{1}%
        {Ç}{{\c{C}}}{1}%
        {Œ}{{\OE}}{1}%
        {Ê}{{\^E}}{1}%
        {ê}{{\^e}}{1}%
        {î}{{\^i}}{1}%
        {ô}{{\^o}}{1}%
        {û}{{\^u}}{1}%
        {ë}{{\¨{e}}}1
        {û}{{\^{u}}}1
        {â}{{\^{a}}}1
        {Â}{{\^{A}}}1
        {Î}{{\^{I}}}1,
}
\newcommand{\deriv}{\mathrm{d}}
\usepackage{array,multirow,makecell}
\usepackage[top=3cm, bottom=3cm, left=3cm,right=3cm]{geometry}
\usepackage{bbold}


\newtheorem{lemma}{Lemme}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[L]{M. \bsc{Augé} et M. \bsc{Roux}}
\fancyhead[C]{}
\fancyhead[R]{Challenge ROADEF}
\renewcommand{\headrulewidth}{1pt}
\fancyfoot[C]{\thepage}

\newcolumntype{C}[1]{>{\centering\arraybackslash }b{#1}}
\setcounter{MaxMatrixCols}{20}
\renewcommand{\footrulewidth}{1pt}

\title{Challenge ROADEF}
\date{\today}
\author{}

\begin{document}

\tableofcontents

\section{Étude bibliographique}
    \section{A tabu search algorithm for large-scale guillotine
    (un)constrained two-dimensional cutting problems\cite{alvarez2002tabu}}
    \paragraph{Objectif de l'article :} Présenter différents algorithmes, constructifs ou non, ainsi que plusieurs heuristiques en vue de résoudre le TDC (expliqué après).

    \paragraph{Problème considéré :} \textit{Two-dimensional cutting problem} = \textbf{une} grande feuille de papier et un ensemble de pièces \textbf{rectangulaires} à découper. Chaque pièce a une \textbf{valeur} et il s'agit de \textbf{maximiser} la valeur totale découpée. À la différence avec notre problème, il n'y a \textbf{ni défauts, ni contrainte de tailles, ni contraintes d'ordre}... Le problème est donc différent. De plus, les différentes pièces ont encore une fois des offres et des demandes différentes. Toutefois, on dispose des \textbf{contraintes guillotines} (notons que les pièces ne peuvent pas roter ici) (la rotation semble être une liberté très importante).

    \paragraph{}Les TDC se classent en quatre catégories : 
    \begin{enumerate}
        \item \textit{The unconstrained unweighted version} (UU\_TDC) : la valeur d'une pièce est égale à sa surface. On cherche à maximiser la surface utilisée (ce que nous on veut, d'une certaine manière).
        \item \textit{The unconstrained weighted version} (UW\_TDC): Chaque pièce a une certaine valeur, indépendante de sa surface (a priori). Pas ce qu'on veut.
        \item \textit{The constrained unweighted version} (CU\_TDC): On contraint sur les quantités à produire de chaque pièce. Il s'agit encore plus de notre problème puis-ce qu'on impose ici de couper 1 fois chaque pièce.
        \item \textit{The constrained weighted version}
    \end{enumerate}

    \begin{itemize}
        \item Des algorithmes exacts existent pour des petites et moyennes instances. Pour les autres, il y a des heuristiques : l'une d'elle se base sur une recherche en profondeur d'abord suivie d'une \textit{hill climbing strategy} (algorithme DH)
    \end{itemize}

    \paragraph{A constructive heuristic algorithm} : L'idée est de considérer, pour chaque sous-rectangle à découper toutes les pièces possibles (ainsi que ses orientations) :\\
     Pour une pièce placée dans le coin inférieur gauche, une guillotine va faire deux nouvelles pièces. On calcule pour chacune d'entre elle une borne supérieure de ce qu'on pourrait y mettre en résolvant un problème du sac-à-dos. L'idée étant de faire en sorte de pouvoir en mettre un maximum.\\ 
    Utilisation de l'algorithme \textit{fast greedy algorithm} de Martello et Toth pour obtenir cette valeur (suffisamment décrit dans l'article).\\
    L'autre borne sup. proposée dans l'article ne s'applique pas à notre problème puis-ce qu'on ne découpe pas plusieurs fois une pièce.\\
    Cet algorithme revient à notre algorithme glouton.

    \paragraph{A GRASP algorithm: } GRASP pour \textit{greedy adaptative search procedure} (greedy = glouton). À chaque itération de GRASP il y a une partie constructive et une procédure d'échange (recherche locale).\\
    L'algorithme se structure comme tel :
    \begin{enumerate}
        \item On prend un rectangle courant (le plus petit ou le premier, pour vérifier la contrainte d'ordre dans notre cas).
        \item Pour chaque pièce qui rentre on calcule un score intelligent (le max des bornes sup + la valeur de la pièce). Score max noté $B$.
        \item On prend aléatoirement une pièce possible parmi toutes celles qui ont un score $\geq \delta.B$ où $\delta$ est un paramètre d'acceptation (=> on rajoute de l'aléa pour parcourir plus de solutions).
        \item Ensuite, on fusionne les pièces déchets avec les pièces adjacentes dans l'optique de créer un grand rectangle qui puisse être redécoupé. Des pièces dites adjacentes sont des pièces qui ont un côté (obligatoirement entier ici) en commun c-à-d deux enfants d'un même papa.
        \item On réapplique le glouton sur le rectangle fusionné. 
    \end{enumerate}
    \textbf{Attention :} Ça va être la grosse merde pour vérifier la contrainte d'ordre ce truc non ?

    \paragraph{A tabu search algorithm} :
    \begin{itemize}
        \item Un \textit{move} qui doit vérifier la contrainte guillotine. Ce que eux décrivent : étant donné deux rectangles qui partagent un morceau de côté en commun et considérent le plus petit rectangle qui les contienne tous les deux. Ils déterminent ensuite le plus petit rectangle dont la guillotine cut correspond. Ils vident alors ce rectangle et le 
        redécoupent avec l'algorithme GRASP.
        \item La \textit{sélection du move} : à chaque itération ils selectionnent uniformément un rectangle (pièces et déchets). Ensuite, pour chaque rectangle voisin ils fusionent pour obtenir un plus grand rectangle (\textit{le move}). On ne fait rien s'il n'y pas de waste sur cette partie. 
        \item On apliquant le move pour chacun de ses voisins, on obtient plusieurs cutting patterns différents. On sélectionne celui qui améliore la fonction objectif.
        \item La \textit{tabu list} : pour chaque move, ils conservent dans la liste les coordonnées et dimensions des rectangles coupés à nouveau ainsi que le type de pièce dans le coin inférieur gauche.\\
        Si on améliore pas la solution courante, on change la longueur de la liste aléatoirement.
        \item La \textit{basic tabu search procedure} : Description générale de l'algorithme.
    \end{itemize} 
    
    \paragraph{Remarques} : Le voisinage peut-être très général et conduire à refaire entièrement la répartition au sein d'un bin. Une amélioration dans la fonction de décision est de considérer les $n$ meilleures solutions courantes et de changer la valeur des pièces en fonction de leurs apparitions dans ces solutions : plus une pièce apparaît souvent dans les meilleurs solutions, plus on a envie de la garder.

    \paragraph{Path relinking :} Étant donné deux solutions, on peut passer de l'une à l'autre en effectuant des échanges puis en parcourant ces chemins on arrive à faire de grandes choses...

\section{Remarques prélimininaires sur le sujet}
    \subsection{Définitions}
        \begin{itemize}
            \item Un \textbf{jumbo} est une grande fenêtre. Ils sont ordonnés dans un \textbf{bin}.
            \item Une \textbf{fenêtre/vitre/item} est une petite fenêtre.
            \item Les \textbf{fenêtres} sont ordonnées au sein de stacks (ordre d'extraction strict) qui eux ne sont pas ordonnés.
            \item Peut-on commencer par un Tooceuht ?
        \end{itemize}



\bibliographystyle{abbrv}
\bibliography{biblio}
\end{document}
